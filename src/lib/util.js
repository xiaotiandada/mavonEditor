/**
 * Created by zhy on 2016/12/25.
 */
/**
 * 深度拷贝对象
 * @param target
 * @param arg
 * @returns {*}
 * @constructor
 */
export function p_ObjectCopy_DEEP(target, arg) {
  for (let arg_item in arg) {
    let type = typeof arg[arg_item];
    if (!target[arg_item] || (type !== 'Object' && type !== 'object')) {
      target[arg_item] = arg[arg_item];
      continue;
    } else {
      target[arg_item] = p_ObjectCopy_DEEP(target[arg_item], arg[arg_item]);
    }
  }
  return target;
};
/**
 * 解析url参数
 */
export function p_urlParse() {
  let url = window.location.search;
  let obj = {};
  let reg = /[?&][^?&]+=[^?&]+/g;
  let arr = url.match(reg);
  if (arr) {
    arr.forEach((item) => {
      let tempArr = item.substring(1).split('=');
      let key = decodeURIComponent(tempArr[0]);
      let val = decodeURIComponent(tempArr[1]);
      obj[key] = val;
    })
  }
  return obj;
};

export function stopEvent(e) {
  if (!e) {
    return;
  }
  if (e.preventDefault) {
    e.preventDefault();
  }
  if (e.stopPropagation) {
    e.stopPropagation();
  }
};

// Generate unique IDs for use as pseudo-private/protected names.
// Similar in concept to
// <http://wiki.ecmascript.org/doku.php?id=strawman:names>.
//
// The goals of this function are twofold:
//
// * Provide a way to generate a string guaranteed to be unique when compared
//   to other strings generated by this function.
// * Make the string complex enough that it is highly unlikely to be
//   accidentally duplicated by hand (this is key if you're using `ID`
//   as a private/protected name on an object).
//
// Use:
//
//     var privateName = ID();
//     var o = { 'public': 'foo' };
//     o[privateName] = 'bar';
export function ID() {
  // Math.random should be unique because of its seeding algorithm.
  // Convert it to base 36 (numbers + letters), and grab the first 9 characters
  // after the decimal.
  return '_' + Math.random().toString(36).substr(2, 9);
};

export const sleep = time => new Promise(resolve => setTimeout(resolve, time))
